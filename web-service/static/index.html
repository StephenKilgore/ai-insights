<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Insights - Sentiment Analysis</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-cloud/1.2.5/d3.layout.cloud.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            width: 80%;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        header {
            text-align: center;
            padding: 20px;
        }
        header img {
            width: 100px;
            margin-bottom: 20px;
        }
        header h1 {
            margin: 0;
        }
        .section-title {
            text-align: center;
            margin-top: 40px;
        }
        .chart-container {
            padding: 20px;
            text-align: center;
        }
        .chart-description {
            text-align: center;
            font-size: 1.1em;
            margin-bottom: 20px;
        }
        .example-tweets {
            padding: 20px;
            background-color: #e9f5ff;
            border-radius: 8px;
            margin-top: 20px;
        }
        .tweet {
            padding: 10px;
            margin: 10px 0;
            background-color: #f4f4f4;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <header>
        <img src="path/to/your/logo.png" alt="AI Insights Logo">
        <h1>AI Insights</h1>
        <p>Measuring public sentiment towards AI topics using Twitter as the dataset</p>
    </header>

    <div class="container">
        <h2 class="section-title">Project Explanation</h2>
        <p>AI Insights is a project aimed at measuring public sentiment towards AI topics using Twitter as the dataset. We collect and analyze tweets to understand how people feel about various aspects of artificial intelligence.</p>

        <h2 class="section-title">What is Sentiment Analysis?</h2>
        <p>Sentiment analysis is the process of determining the emotional tone behind a series of words, used to gain an understanding of the attitudes, opinions, and emotions expressed within an online mention.</p>
        <p>Our analysis involves the following data points:</p>
        <ul>
            <li><b>Sentiment Score:</b> A numerical value indicating the sentiment's positivity, negativity, or neutrality.</li>
            <li><b>Sentiment Magnitude:</b> A numerical value representing the strength or intensity of the sentiment.</li>
            <li><b>Sentiment Text:</b> Categorizes the sentiment as positive, negative, or neutral.</li>
        </ul>

        <h2 class="section-title">Sentiment Categories Breakdown</h2>
        <p>We categorize sentiments into the following:</p>
        <ul>
            <li><b>Positive:</b> Tweets expressing a positive sentiment.</li>
            <li><b>Negative:</b> Tweets expressing a negative sentiment.</li>
            <li><b>Neutral:</b> Tweets expressing a neutral sentiment.</li>
        </ul>
    </div>

    <div class="container">
        <div class="chart-container">
            <h2 class="section-title">Sentiment Distribution</h2>
            <div class="chart-description">This pie chart shows the proportion of positive, negative, and neutral tweets. The distribution helps in understanding the overall sentiment towards AI.</div>
            <div id="sentiment-pie"></div>
        </div>

        <div class="chart-container">
            <h2 class="section-title">Sentiment Trends Over Time</h2>
            <div class="chart-description">This line chart shows sentiment trends over time. Monitoring sentiment trends can reveal changes in public opinion and identify significant events that impact sentiment.</div>
            <div id="sentiment-line"></div>
        </div>

        <div class="chart-container">
            <h2 class="section-title">Sentiment Frequency</h2>
            <div class="chart-description">This bar chart compares the frequency of different sentiment categories. The frequency of each sentiment type can help prioritize areas of interest or concern.</div>
            <div id="sentiment-bar"></div>
        </div>

        <div class="chart-container">
            <h2 class="section-title">Word Cloud</h2>
            <div class="chart-description">This word cloud shows the most frequent words used in tweets, colored by sentiment category. It provides a quick visual impression of the key topics and terms associated with each sentiment.</div>
            <div id="word-cloud"></div>
        </div>

        <div class="chart-container">
            <h2 class="section-title">Sentiment Score and Magnitude</h2>
            <div class="chart-description">This scatter plot displays sentiment scores and magnitudes. By examining both scores and magnitudes, we can identify the strength and polarity of public sentiment.</div>
            <div id="sentiment-scatter"></div>
        </div>

        <div class="chart-container">
            <h2 class="section-title">Sentiment Intensity</h2>
            <div class="chart-description">This heatmap shows sentiment intensity over time or by category.</div>
            <div id="sentiment-heatmap"></div>
        </div>
    </div>

    <div class="container">
        <h2 class="section-title">Example Tweets</h2>

        <div class="example-tweets">
            <h3>Positive Tweets</h3>
            <div id="positive-tweets">
                <!-- Positive tweets will be inserted here -->
            </div>
        </div>

        <div class="example-tweets">
            <h3>Negative Tweets</h3>
            <div id="negative-tweets">
                <!-- Negative tweets will be inserted here -->
            </div>
        </div>

        <div class="example-tweets">
            <h3>Neutral Tweets</h3>
            <div id="neutral-tweets">
                <!-- Neutral tweets will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        async function fetchData() {
            const response = await fetch('/api/message');
            const data = await response.json();
            return data;
        }

        fetchData().then(data => {
            // Process the data and create the charts
            if (data && Array.isArray(data)) {
                createPieChart(data);
                createLineChart(data);
                createBarChart(data);
                createWordCloud(data);
                createScatterPlot(data);
                createHeatmap(data);

                // Display example tweets
                displayExampleTweets(data);
            } else {
                console.error("Invalid data format:", data);
            }
        });

        function createPieChart(data) {
            // Extract sentiment counts
            const sentimentCounts = d3.rollup(data, v => v.length, d => d.sentiment_text);

            const width = 400, height = 400, radius = Math.min(width, height) / 2;
            const color = d3.scaleOrdinal()
                            .domain(["positive", "negative", "neutral"])
                            .range(["green", "red", "grey"]);

            const svg = d3.select("#sentiment-pie")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            const pie = d3.pie().value(d => d[1]);
            const arc = d3.arc().innerRadius(0).outerRadius(radius);

            svg.selectAll('path')
                .data(pie(Array.from(sentimentCounts)))
                .enter()
                .append('path')
                .attr('d', arc)
                .attr('fill', d => color(d.data[0]));

            // Add legend
            const legend = svg.append("g")
                .attr("transform", `translate(${width / 2 - 100}, ${-height / 2 + 20})`);

            legend.selectAll("rect")
                .data(color.domain())
                .enter()
                .append("rect")
                .attr("x", 0)
                .attr("y", (d, i) => i * 20)
                .attr("width", 18)
                .attr("height", 18)
                .style("fill", color);

            legend.selectAll("text")
                .data(color.domain())
                .enter()
                .append("text")
                .attr("x", 24)
                .attr("y", (d, i) => i * 20 + 14)
                .text(d => d);
        }

        function createLineChart(data) {
            // Extract data for line chart
            const sentimentByDate = d3.rollup(data, v => d3.mean(v, d => d.sentiment_score), d => new Date(d.created_at));

            const margin = {top: 20, right: 30, bottom: 30, left: 40},
                  width = 600 - margin.left - margin.right,
                  height = 400 - margin.top - margin.bottom;

            const x = d3.scaleTime()
                .domain(d3.extent(sentimentByDate.keys()))
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([-1, 1])
                .range([height, 0]);

            const svg = d3.select("#sentiment-line")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            svg.append("g")
                .call(d3.axisLeft(y));

            const line = d3.line()
                .x(d => x(d[0]))
                .y(d => y(d[1]));

            svg.append("path")
                .datum(Array.from(sentimentByDate))
                .attr("fill", "none")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 1.5)
                .attr("d", line);
        }

        function createBarChart(data) {
            const sentimentCounts = d3.rollup(data, v => v.length, d => d.sentiment_text);

            const margin = {top: 20, right: 30, bottom: 40, left: 90},
                  width = 460 - margin.left - margin.right,
                  height = 400 - margin.top - margin.bottom;

            const svg = d3.select("#sentiment-bar")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear()
                .domain([0, d3.max(Array.from(sentimentCounts.values()))])
                .range([0, width]);

            const y = d3.scaleBand()
                .range([0, height])
                .domain(sentimentCounts.keys())
                .padding(.1);

            svg.append("g")
                .call(d3.axisLeft(y));

            svg.selectAll("rect")
                .data(Array.from(sentimentCounts))
                .enter()
                .append("rect")
                .attr("x", x(0))
                .attr("y", d => y(d[0]))
                .attr("width", d => x(d[1]))
                .attr("height", y.bandwidth())
                .attr("fill", d => {
                    if (d[0] === "positive") return "green";
                    else if (d[0] === "negative") return "red";
                    else return "grey";
                });
        }

        function createWordCloud(data) {
            const words = data.map(d => d.text.split(" ")).flat();
            const frequency = Array.from(d3.rollup(words, v => v.length, d => d), ([word, size]) => ({text: word, size: size}));

            const width = 600, height = 400;

            const layout = d3.layout.cloud()
                .size([width, height])
                .words(frequency)
                .padding(5)
                .rotate(() => ~~(Math.random() * 2) * 90)
                .font("Impact")
                .fontSize(d => d.size)
                .on("end", draw);

            layout.start();

            function draw(words) {
                d3.select("#word-cloud")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .append("g")
                    .attr("transform", `translate(${width / 2}, ${height / 2})`)
                    .selectAll("text")
                    .data(words)
                    .enter()
                    .append("text")
                    .style("font-size", d => `${d.size}px`)
                    .style("font-family", "Impact")
                    .attr("text-anchor", "middle")
                    .attr("transform", d => `translate(${[d.x, d.y]})rotate(${d.rotate})`)
                    .text(d => d.text);
            }
        }

        function createScatterPlot(data) {
            const margin = {top: 20, right: 30, bottom: 40, left: 90},
                  width = 460 - margin.left - margin.right,
                  height = 400 - margin.top - margin.bottom;

            const svg = d3.select("#sentiment-scatter")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear()
                .domain([-1, 1])
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.sentiment_magnitude)])
                .range([height, 0]);

            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            svg.append("g")
                .call(d3.axisLeft(y));

            svg.append('g')
                .selectAll("dot")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", d => x(d.sentiment_score))
                .attr("cy", d => y(d.sentiment_magnitude))
                .attr("r", 5)
                .style("fill", d => {
                    if (d.sentiment_text === "positive") return "green";
                    else if (d.sentiment_text === "negative") return "red";
                    else return "grey";
                });
        }

        function createHeatmap(data) {
            const margin = {top: 20, right: 30, bottom: 40, left: 90},
                  width = 460 - margin.left - margin.right,
                  height = 400 - margin.top - margin.bottom;

            const svg = d3.select("#sentiment-heatmap")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const heatmapData = Array.from(d3.rollups(data, v => v.length, d => d.created_at, d => d.sentiment_text),
                                  ([date, sentiments]) => sentiments.map(([sentiment, count]) => ({
                                      date: new Date(date),
                                      sentiment: sentiment,
                                      intensity: count
                                  }))).flat();

            const x = d3.scaleBand()
                .domain(heatmapData.map(d => d.date))
                .range([0, width])
                .padding(0.01);

            const y = d3.scaleBand()
                .domain(heatmapData.map(d => d.sentiment))
                .range([height, 0])
                .padding(0.01);

            const color = d3.scaleSequential()
                .interpolator(d3.interpolateBlues)
                .domain([0, d3.max(heatmapData, d => d.intensity)]);

            svg.selectAll()
                .data(heatmapData, d => d.date + ':' + d.sentiment)
                .enter()
                .append("rect")
                .attr("x", d => x(d.date))
                .attr("y", d => y(d.sentiment))
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", d => color(d.intensity));

            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%Y-%m-%d")));

            svg.append("g")
                .call(d3.axisLeft(y));
        }

        function displayExampleTweets(data) {
            const positiveTweets = data.filter(d => d.sentiment_text === 'positive').slice(0, 5);
            const negativeTweets = data.filter(d => d.sentiment_text === 'negative').slice(0, 5);
            const neutralTweets = data.filter(d => d.sentiment_text === 'neutral').slice(0, 5);

            const positiveList = d3.select("#positive-tweets");
            const negativeList = d3.select("#negative-tweets");
            const neutralList = d3.select("#neutral-tweets");

            positiveTweets.forEach(tweet => {
                positiveList.append("div").attr("class", "tweet").text(tweet.text);
            });

            negativeTweets.forEach(tweet => {
                negativeList.append("div").attr("class", "tweet").text(tweet.text);
            });

            neutralTweets.forEach(tweet => {
                neutralList.append("div").attr("class", "tweet").text(tweet.text);
            });
        }
    </script>
</body>
</html>
